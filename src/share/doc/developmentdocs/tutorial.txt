1. Architectural foundations

LiteCommerce is an object-oriented application with open API. It has a modular structure and consists of a single core with some external modules. Each module can change (or extend) each class'es behaviour whithout changing its source code. This enables third-party developers to implement their own modules.

It is easy to install a new module into working LiteCommerce shop. Modules come in .tar files, which you upload in the module installator in your admin area.

LiteCommerce has its own DB layer, which encapsulates all Database calls and frees the source code from tons of SQL statements. There is no longer need to remember all table fields in order to enumerate them in your select or update statement.

1.1. A common application run

The common LiteCommerce application run cycle is shown in cart.gif. There you can see four methods of the classes/XLite.php class. Methods are called from either cart.php or admin.php.

Each GET or POST request usually contains two parameters: 'target' and' action'. A target is used by kernel/RequestBrocker.php to locate the propriate dialog class file which is responsible for this dialog. For example, 'target=cart' will wake up the class classes/dialog/cart.php. RequestBrocker than calls the handleRequest() function of the instantiated dialog class. As you can see in classes/base/Dialog.php, the standard handleRequest() behaviour is to call method called action_$action, whete $action is the 'action' parameter of the http request. The default action value is 'default', the default target is 'main'. So, the request http:/xxx/cart.php is equivalent to http:/xxx/cart.php?target=main&action=default. This request is processed in classes/dialog/main.php, method action_default().

A typical action functionality may include, among all, a redirect:

   Header::location("cart.php?target=cart"); // redirect example

or initialization of the view (the view system's described below):

   $this->initWidget("Cart"); // show widget named 'Cart', see below

You may call other actions as well and make kernel calls.


1.2. Visualization system

Everithing LiteCommerce outputs to a customer is a 'widget'. Widget is a grafical user interface component visible to an end-user and corresponding to a Flexy template. So that widget is a programming object corresponding to each template in the system. Templates are located in the skins/admin/en (admin zone) and skins/default/en (customer zone). The 'default' word itself designates the current skin and therefore should never be used directly.

Each widget is an object of the class base/Widget or its descentants. Customer zone Widget classes are located in the 'view' directory, admin zone - in 'admin/view'. Widget objects are nested, as templates can be nested. The nesting of widgets creates a widget tree with one top-level widget (the widget class view/Main in customer zone and admin/view/Main in admin zone). Each widget object (not class!) has its name, so that you can refer to a widget by name using the following syntax:

	$widget =& Widget::getByName("CheckoutRegistration");

Note the reference ('&') sign - it is neccessary because there should be only one object for each widget in the system at the same time.

widgets perform the following tasks:
	a. create their subwidgets sub-tree in its constructor() function at the LiteCommerce initialization phase (see $xlite->init(new View_Main()) call in cart.php);
	b. initialize its data and subwidgets - in its init() function - it is called after the user request has been processed and the $dialog->handleRequest() returns its control;
	c. display() displays the widget just after all the tree was creates and initialized. The default Widget::display() method displays the corresponding template;

2. Creating Modules

A module in LiteCommerce adds some extra functionality or changes the default cart behaviour. Modules can be installed, removed, and deactivated. A LiteCimmerse module is truly plug-n-play in a scence that it can change the behaviour of LiteCommerse without changing/patching existing php files. This property is achieved using class inheritance: module does not change php code itself, however it inherits and overrides the kernel LiteCommerce classes/methods. Several modules can modify the same kernel class, so that module classes are inherited from each other. An example is the View_Main class (view/Main.php) - both FetauredProducts and DetailedImages modules modify it adding new widgets to the main page. If you turn on both modules, LiteCommerce will create the following inheritance chain:

View_Main <- Detailed_Images_View_Main <- Module_FeaturedProducts_Admin_View_Main__

The classes ended with '__' are auto-generated classes with replace 'extends' clause. For example, the Module_FeaturedProducts_Admin_View_Main__ class is generated from Module_FeaturedProducts_Admin_View_Main by replacing its 'extends View_Main' with 'extends Detailed_Images_View_Main'. Each time you call 'new View_Main' actually LiteCommerce creates an instance of Module_FeaturedProducts_Admin_View_Main__ class. There is a standard design pattern called 'Decorator' which acts in such way. The child classes are called 'Decorators' as they modifies the main class. To add a decorator in a module, call the $this->addDecorator() method from the module init() method. When module is active, its init() method is called each time at the LiteCommerse startup phase.

How to replace one template with another from a module:

  Decorate the kernel/Layout.php class. Replace the getLayout function:
  
	function getLayout($widgetName, $template = '')
	{
		if ($widgetName == 'AdminWelcome') {
			return $this->getPath() . 'modules/MyModule/welcome.tpl';
		}
		return parent::getLayout($widgetName, $template);
	}

  Place your template in skins/admin/en/modules/MyModule/welcome.tpl	


How to create a calculated database field:
  
  To create a calculated field in a table, decorate the corresponding class, e.g. kernel/Product.php. The following code creates a field named 'weight_type' inside the Product object. It takes one of two values: light or heavy, regarding of the product's weight:

	function get($name)
	{
		if ($name == 'weight_type') {
			return $this->get('weight') < 100 ? 'light' : 'heavy';
		} else {
			return parent::get($name);
		}
	}
	
How to create an additional data field in a table:

  Creating a data field is a little bit more complicated task. First, your need to create the field during module installation. Define the install function in your module:

	function install()
	{
		parent::install();
		$this->alterTable("products", "alter table xlite_products add isbn varchar(100)");
		$this->success();
	}

  Alter table clause will ignore errors if the field is already exists from your previous module version. Now you must specify the field 'isbn' in the database layer. Decorate the kernel/Product class and replace its constructor:
  
	function constructor($id = null)
	{
		$this->_properties['isbn'] = ''; // this is the default isbn value
  		parent::constructor($id);
	}

  Use $product->get('isbn'), $product->set('isbn', '123') to access the ISBN field.

How to create new relations:

  Just create a class and inherit it from the base/Base class. Put it in classes/modules/YouModule/kernel directory. Do not forget to maintain foreign keys: say, if your table links to the products table, that you might want to remove everything from this table corresponding to the removed product. The following is an example of how Featured Products remove featured product rows when the product is removed:

	class Module_FeaturedProducts_Product extends Product
	{
		function delete()
		{
			$this->connection->query("DELETE FROM " . FEATURED_PRODUCTS_TABLE . " WHERE product_id='" . $this->get("product_id") . "'");
			parent::delete();
		}
	}


How to add fields into forms

  In some form templates (specifically, profile forms, product form) there is the following line below oll form fields:

  	{extraFields.display()}

  this is where you can add your html code from modules. Lets consider an example of adding 'bonusPoints' field into profile form, customer zone. First of all, decorate the view/Profile widget:

	class Module_YourModule_Admin_View_Profile extends Admin_View_Profile
	{
	  function constructor()
	  {
	  	parent::constructor();
		$bonusField =& $this->createWidget($name, "modules/YourModule/bonus_points.tpl");
		if (isset($this->body->extraFields)) {
			// check if there are more modules who binds to the extraFields
			$this->body->extraFields->addExtraWidget($bonusField);
		} else {
			// extraFields is empty, set it to a single $bonusField
			$this->body->extraFields =& $bonusField;
		}
	  }
	}

  Remember that '$this'	is a DialogWidget widget and corresponds to the common/dialog.tpl template, not the profile form itself. To refer to the form widget, use $this->body. Then create the bonus field template, which may look like following:

  {* bonus points information field in the customer's profile; not editable *}
  <tr valign="middle">
      <td align="right">Bonus points</td>
      <td>&nbsp;</td>
      <td>{dialog.bonusPoints:r}</td>
  </tr>
			  
How to register your own payment method:

	To create a new payment method from your module, first inherit the kernel/PaymentMethod class - put it in classes/modules/YourModule/kernel/PaymentMethod/new-method-name.php. Than, register the payment method in your module's init() function:

	$pm =& new PaymentMethod;
    $pm->registerMethod("new-method-name");

	The LiteCommerce core will automatically locate and include the corresponding php file. The key payment method methods shoul be implemented are:
	getProcessorName() - returns the payment method display name
	&getFormWidget() - returns a reference to the form's widget object. Eaxample:
    function &getFormWidget()
    {
        static $widget;
        if (!isset($widget)) {
            $widget = new Widget();
            $widget->setName("BonusPointsCheckout");
            $widget->setTemplate("modules/Promotion/checkout.tpl");
        }
        return $widget;
    }

	handleRequest(&$cart) - pays the order; is called during checkout.

	See other methods in kernel/PaymentMethod.php
