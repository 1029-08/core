<?php
// vim: set ts=4 sw=4 sts=4 et:

/**
 * LiteCommerce
 * 
 * NOTICE OF LICENSE
 * 
 * This source file is subject to the Open Software License (OSL 3.0)
 * that is bundled with this package in the file LICENSE.txt.
 * It is also available through the world-wide-web at this URL:
 * http://opensource.org/licenses/osl-3.0.php
 * If you did not receive a copy of the license and are unable to
 * obtain it through the world-wide-web, please send an email
 * to licensing@litecommerce.com so we can send you a copy immediately.
 * 
 * @category   LiteCommerce
 * @package    XLite
 * @subpackage Includes
 * @author     Creative Development LLC <info@cdev.ru> 
 * @copyright  Copyright (c) 2011 Creative Development LLC <info@cdev.ru>. All rights reserved
 * @license    http://opensource.org/licenses/osl-3.0.php Open Software License (OSL 3.0)
 * @version    SVN: $Id$
 * @link       http://www.litecommerce.com/
 * @see        ____file_see____
 * @since      3.0.0
 */

namespace Includes\Decorator\Utils;

/**
 * Operator 
 * 
 * @package    XLite
 * @see        ____class_see____
 * @since      3.0.0
 */
abstract class Operator extends \Includes\Decorator\Utils\Base\Operator
{
    /**
     * Suffix for a base class in decorator chain
     */
    const BASE_CLASS_SUFFIX = 'Abstract';


    // ------------------------------ Write class file routines -

    /**
     * Return name of PHP class file
     *
     * @param \Includes\Decorator\DataStructure\Node\ClassInfo $info Class info
     *
     * @return string
     * @access public
     * @see    ____func_see____
     * @since  3.0.0
     */
    public static function getClassFileName(\Includes\Decorator\DataStructure\Node\ClassInfo $info)
    {
        return str_replace('\\', LC_DS, \Includes\Utils\Converter::trimLeadingChars($info->getClass(), '\\'));
    }

    /**
     * Return path of PHP class file
     * 
     * @param \Includes\Decorator\DataStructure\Node\ClassInfo $info Class info
     *  
     * @return string
     * @access public
     * @see    ____func_see____
     * @since  3.0.0
     */
    public static function getClassFilePath(\Includes\Decorator\DataStructure\Node\ClassInfo $info)
    {
        return LC_CLASSES_CACHE_DIR . static::getClassFileName($info) . '.php';
    }

    /**
     * Return content of PHP class file
     *
     * @param \Includes\Decorator\DataStructure\Node\ClassInfo $info Class info
     *
     * @return string
     * @access protected
     * @see    ____func_see____
     * @since  3.0.0
     */
    protected static function getClassFileContent(\Includes\Decorator\DataStructure\Node\ClassInfo $info)
    {
        $content = $info->{self::N_IS_EMPTY} 
            ? static::getEmptyClassDefinition($info) 
            : static::getRegularClassDefinition($info);

        // Prepare static members
        \Includes\Decorator\Utils\StaticRoutines::checkForStaticConstructor($info, $content);

        return $content;
    }

    /**
     * Return content for so called "root" (autogenerated) class files
     *
     * @param \Includes\Decorator\DataStructure\Node\ClassInfo $info Autogenerated class info
     *
     * @return string
     * @access protected
     * @see    ____func_see____
     * @since  3.0.0
     */
    protected static function getEmptyClassContent(\Includes\Decorator\DataStructure\Node\ClassInfo $info)
    {
        return '';
    }

    /**
     * Return content for so called "root" (autogenerated) class files
     * 
     * @param \Includes\Decorator\DataStructure\Node\ClassInfo $info Autogenerated class info
     *  
     * @return string
     * @access protected
     * @see    ____func_see____
     * @since  3.0.0
     */
    protected static function getEmptyClassDefinition(\Includes\Decorator\DataStructure\Node\ClassInfo $info)
    {
        return '<?php' . "\n\n"
            . 'namespace ' . $info->getNamespace() . ';' . "\n\n"
            . $info->{self::N_CLASS_COMMENT} . "\n"
            . (empty($info->{self::N_CLASS_TYPE}) ? '' : ($info->{self::N_CLASS_TYPE} . ' '))
            . 'class ' . $info->getBasename() . ' '
            . 'extends ' . $info->getParent()->getClass()
            . ($info->getInterfaces() ? (' implements ' . implode(', ', $info->getInterfaces())) : '') . "\n"
            . '{' . "\n" . static::getEmptyClassContent($info) . "\n" . '}';
    }

    /**
     * Return content for regular class files
     *
     * @param \Includes\Decorator\DataStructure\Node\ClassInfo $info Class info
     *
     * @return string
     * @access protected
     * @see    ____func_see____
     * @since  3.0.0
     */
    protected static function getRegularClassContent(\Includes\Decorator\DataStructure\Node\ClassInfo $info)
    {
        return \Includes\Utils\FileManager::read(LC_CLASSES_DIR . $info->{self::N_FILE_PATH});
    }

    /**
     * Return replacement data for regular class files
     *
     * @param \Includes\Decorator\DataStructure\Node\ClassInfo $info Class info
     *
     * @return array
     * @access protected
     * @see    ____func_see____
     * @since  3.0.0
     */
    protected static function getRegularClassReplacement(\Includes\Decorator\DataStructure\Node\ClassInfo $info)
    {
        return array(
            self::N_NAMESPACE     => $info->getNamespace(),
            self::N_CLASS_COMMENT => $info->{self::N_CLASS_COMMENT},
            self::N_CLASS         => $info->getBasename(),
            self::N_PARENT_CLASS  => $info->getParent()->getClass(),
        );
    }

    /**
     * Return content for regular class files
     *
     * @param \Includes\Decorator\DataStructure\Node\ClassInfo $info Class info
     *
     * @return string
     * @access protected
     * @see    ____func_see____
     * @since  3.0.0
     */
    protected static function getRegularClassDefinition(\Includes\Decorator\DataStructure\Node\ClassInfo $info)
    {
        return \Includes\Decorator\Utils\Parser::prepareClassDefintion(
            static::getRegularClassContent($info),
            static::getRegularClassReplacement($info)
        );
    }

    /**
     * Write PHP class file to the file system
     * 
     * @param Includes\Decorator\DataStructure\Node\ClassInfo $info Class description
     *  
     * @return null
     * @access protected
     * @see    ____func_see____
     * @since  3.0.0
     */
    protected static function writeClassFile(\Includes\Decorator\DataStructure\Node\ClassInfo $info)
    {
        $info->isStub() ?: \Includes\Utils\FileManager::write(
            static::getClassFilePath($info),
            static::getClassFileContent($info)
        );
    }


    // ------------------------------ Decorator routines -

    /**
     * Return module name by class name
     * 
     * @param \Includes\Decorator\DataStructure\Node\ClassInfo $info Class info
     *  
     * @return string
     * @access protected
     * @see    ____func_see____
     * @since  3.0.0
     */
    protected static function getModuleName(\Includes\Decorator\DataStructure\Node\ClassInfo $info)
    {
        return \Includes\Decorator\Utils\ModulesManager::getModuleNameByClassName($info->getClass());
    }

    /**
     * Return class (module) weight by class name
     *
     * @param \Includes\Decorator\DataStructure\Node\ClassInfo $info Class info
     *
     * @return integer
     * @access protected
     * @see    ____func_see____
     * @since  3.0.0
     */
    protected static function getModuleWeight(\Includes\Decorator\DataStructure\Node\ClassInfo $info)
    {
        return ($module = static::getModuleName($info)) ? static::getModulesGraph()->getCriticalPaths($module) : 0;
    }

    /**
     * Method to sort classes by their module priorities 
     * 
     * @param \Includes\Decorator\DataStructure\Node\ClassInfo $value1 Class info (first element)
     * @param \Includes\Decorator\DataStructure\Node\ClassInfo $value2 Class info (second element)
     *  
     * @return integer
     * @access protected
     * @see    ____func_see____
     * @since  3.0.0
     */
    protected static function sortDecorators(
        \Includes\Decorator\DataStructure\Node\ClassInfo $value1,
        \Includes\Decorator\DataStructure\Node\ClassInfo $value2
    ) {
        $weight1 = static::getModuleWeight($value1);
        $weight2 = static::getModuleWeight($value2);

        return ($weight1 === $weight2) ? 0 : (($weight1 < $weight2) ? -1 : 1);
    }

    /**
     * Return list of node decorators ordered by their module priorities
     * 
     * @param \Includes\Decorator\DataStructure\Node\ClassInfo $info Class info (node)
     *  
     * @return void
     * @access protected
     * @see    ____func_see____
     * @since  3.0.0
     */
    protected static function getOrderedDecorators(\Includes\Decorator\DataStructure\Node\ClassInfo $info)
    {
        $nodes = $info->getDecorators();
        usort($nodes, array('static', 'sortDecorators'));

        return $nodes;
    }


    // ------------------------------ Public methods -

    /**
     * Main decorator procedure: prepare classes tree
     * 
     * @return null
     * @access public
     * @see    ____func_see____
     * @since  3.0.0
     */
    public static function prepareClassesTree()
    {
        foreach (static::getClassesTree()->getIndex() as $node) {

            if ($decorators = static::getOrderedDecorators($node)) {

                $baseClass = $node->getClass();
                static::getClassesTree()->changeNodeKey($node, $baseClass . self::BASE_CLASS_SUFFIX);
                $parent = $node;

                foreach ($decorators as $decorator) {
                    static::getClassesTree()->replantNode($parent, $decorator);
                    $parent = $decorator;
                }

                static::getClassesTree()->addChildNode(
                    $parent,
                    $new = new \Includes\Decorator\DataStructure\Node\ClassInfo(
                        array(
                            self::N_CLASS         => $baseClass,
                            self::N_IS_EMPTY      => true,
                            self::N_CLASS_COMMENT => $node->{self::N_CLASS_COMMENT},
                            self::N_CLASS_TYPE    => $node->{self::N_CLASS_TYPE},
                        )
                    )
                );

                // FIXME: must be moved to a Doctrine plugin
                if ($node->getTag('Entity')) {
                    $node->{self::N_CLASS_COMMENT} = '/*' . "\n" . ' * @MappedSuperClass' . "\n" . ' */';
                }

                foreach ($node->getChildren() as $child) {
                    $child->isDecorator() ?: static::getClassesTree()->replantNode($new, $child);
                }
            }
        }

        static::getClassesTree()->checkIsTree();
    }

    /**
     * Write PHP classes to the files
     * 
     * @return null
     * @access public
     * @see    ____func_see____
     * @since  3.0.0
     */
    public static function writeClassFiles()
    {
        array_map(array('static', 'writeClassFile'), static::getClassesTree()->getIndex());
    }
}
